/* This program simulates DDS local loop decoding algorithm C.
This algorithm shifts bits one at a time and uses a counter
instead of a shift exponent.
*/

#include <stdio.h>

unsigned int tdata, tbpv;

unsigned int rdata, rbpv;

int k;

main()

{

	test("111x0v111x0v0000000111x0v111x0v111x0v010000000000111x0v");
	test("0111x0v111x0v000000111x0v111x0v111x0v010000000000111x0v");
	test("00111x0v111x0v00000111x0v111x0v111x0v010000000000111x0v");
	test("000111x0v111x0v0000111x0v111x0v111x0v010000000000111x0v");
	test("0000111x0v111x0v000111x0v111x0v111x0v010000000000111x0v");
	test("00000111x0v111x0v00111x0v111x0v111x0v010000000000111x0v");
	test("000000111x0v111x0v0111x0v111x0v111x0v010000000000111x0v");

	printf("\none unaligned cmi test\n");

	test("000000000010111x0v010000000000000000000000111111000000000000");
	test("0000000000010111x0v01000000000000000000000111111000000000000");
	test("00000000000010111x0v0100000000000000000000111111000000000000");
	test("000000000000010111x0v010000000000000000000111111000000000000");
	test("0000000000000010111x0v01000000000000000000111111000000000000");
	test("00000000000000010111x0v0100000000000000000111111000000000000");
	test("000000000000000010111x0v010000000000000000111111000000000000");

	printf("\ntwo unaligned cmi test\n");

	test("000000111x0v111x0v0100000000000000000000");
	test("0000000111x0v111x0v010000000000000000000");
	test("00000000111x0v111x0v01000000000000000000");
	test("000000000111x0v111x0v0100000000000000000");
	test("0000000000111x0v111x0v010000000000000000");
	test("00000000000111x0v111x0v01000000000000000");
	test("000000000000111x0v111x0v0100000000000000");

	printf("\ncmi fields with 6 bits in between\n");

	test("000000111x0v111x0v000000111x0v111x0v01000000000000000000000");
	test("0000000111x0v111x0v000000111x0v111x0v0100000000000000000000");
	test("00000000111x0v111x0v000000111x0v111x0v010000000000000000000");
	test("000000000111x0v111x0v000000111x0v111x0v01000000000000000000");
	test("0000000000111x0v111x0v000000111x0v111x0v0100000000000000000");
	test("00000000000111x0v111x0v000000111x0v111x0v010000000000000000");
	test("000000000000111x0v111x0v000000111x0v111x0v01000000000000000");

	printf("\ncmi fields with 7 bits in between\n");

	test("000000111x0v111x0v0000000111x0v111x0v0100000000000000000000");
	test("0000000111x0v111x0v0000000111x0v111x0v010000000000000000000");
	test("00000000111x0v111x0v0000000111x0v111x0v01000000000000000000");
	test("000000000111x0v111x0v0000000111x0v111x0v0100000000000000000");
	test("0000000000111x0v111x0v0000000111x0v111x0v010000000000000000");
	test("00000000000111x0v111x0v0000000111x0v111x0v01000000000000000");
	test("000000000000111x0v111x0v0000000111x0v111x0v0100000000000000");

	printf("\nsequential cmi\n");

	test("111x0v111x0v111x0v111x0v010000000000000000");
	test("0111x0v111x0v111x0v111x0v01000000000000000");
	test("00111x0v111x0v111x0v111x0v0100000000000000");
	test("000111x0v111x0v111x0v111x0v010000000000000");
	test("0000111x0v111x0v111x0v111x0v01000000000000");
	test("00000111x0v111x0v111x0v111x0v0100000000000");
	test("000000111x0v111x0v111x0v111x0v010000000000");

	test("000000111x0v010000000000000000000000000000");
	test("0000000111x0v01000000000000000000000000000");
	test("00000000111x0v0100000000000000000000000000");
	test("000000000111x0v010000000000000000000000000");
	test("0000000000111x0v01000000000000000000000000");
	test("00000000000111x0v0100000000000000000000000");
	test("000000000000111x0v010000000000000000000000");

	test("000000111x0v111x0v010000000000000000000000");
	test("0000000111x0v111x0v01000000000000000000000");
	test("00000000111x0v111x0v0100000000000000000000");
	test("000000000111x0v111x0v010000000000000000000");
	test("0000000000111x0v111x0v01000000000000000000");
	test("00000000000111x0v111x0v0100000000000000000");
	test("000000000000111x0v111x0v010000000000000000");

	printf("\ntwo cmi with one bit in between\n");

	test("000000111x0v0111x0v01000000000000000000000");
	test("0000000111x0v0111x0v0100000000000000000000");
	test("00000000111x0v0111x0v010000000000000000000");
	test("000000000111x0v0111x0v01000000000000000000");
	test("0000000000111x0v0111x0v0100000000000000000");
	test("00000000000111x0v0111x0v010000000000000000");
	test("000000000000111x0v0111x0v01000000000000000");

	printf("\nloopback sequences\n");

	test("010x0v010000010x0v010000010x0v010000010x0v010000000000");
	test("0010x0v010000010x0v010000010x0v010000010x0v01000000000");
	test("00010x0v010000010x0v010000010x0v010000010x0v0100000000");
	test("000010x0v010000010x0v010000010x0v010000010x0v010000000");
	test("0000010x0v010000010x0v010000010x0v010000010x0v01000000");
	test("00000010x0v010000010x0v010000010x0v010000010x0v0100000");
	test("000000010x0v010000010x0v010000010x0v010000010x0v010000");

	printf("\nzero code\n");

	test("000x0v111111111111111111111111111111111111111111111111");
	test("1000x0v11111111111111111111111111111111111111111111111");
	test("11000x0v1111111111111111111111111111111111111111111111");
	test("111000x0v111111111111111111111111111111111111111111111");
	test("1111000x0v11111111111111111111111111111111111111111111");
	test("11111000x0v1111111111111111111111111111111111111111111");
	test("111111000x0v111111111111111111111111111111111111111111");

	printf("\nrun-on\n");

	test("111x0v0111x0v0111x0v0111x0v0111x0v0111x0v0111x0v0111x0v0111x0v0111x0v0");
	test("111x0v00111x0v00111x0v00111x0v00111x0v00111x0v00111x0v00111x0v00111x0v00111x0v00");

}

test(s)

char *s;

{

	int i, n;

	printf("\n%s\n\n", s);

	rdata = 0;

	rbpv = 0;

	tdata = 0;

	tbpv = 0;

	k = 5;

	n = strlen(s);

	for (i = 0; i < n; i++) {

		tdata <<= 1;

		tbpv <<= 1;

		switch (s[i]) {

		case '1':

		case 'x':

			tdata |= 1;

			break;

		case 'v':

			tdata |= 1;

			tbpv |= 1;

			break;

		}

		if (i % 6 == 5)

			shift6();

	}

}

shift6()

{

	int i, k2;

	k2 = k;

	for (i = 0; i < 6; i++) {

		rdata <<= 1;

		rbpv <<= 1;

		if (tdata & 0x20)

			rdata |= 1;

		if (tbpv & 0x20)

			rbpv |= 1;

		tdata <<= 1;

		tbpv <<= 1;

		/* decode zero */

		if ((rbpv & 1) && (rdata & 0x3b) == 0x01)

			rdata &= ~0x3f;

		/* decode cmi */

		if ((rbpv & 1) && (rdata & 0x3b) == 0x39)

			rdata |= 0x3f;

		/* align */

		if ((rbpv & 0xfff) == 0x41 && (rdata & 0xfff) == 0xfff) {

			k2 = i;

			/* if send() has not been called yet then */

			/* change k immediately */

			if (k >= i)

				k = i;

		}

		/* loop */

		if ((rbpv & 1) && (rdata & 0x3b) == 0x11)

			k2 = i;

		if (i == k)

			send();

	}

	k = k2;

}

send()

{

	int i;

	unsigned int ydata, ybpv;

	ydata = rdata >> 6;

	ybpv = rbpv >> 6;

	if ((ybpv & 0x01) && (ydata & 0x3f) == 0x3f)

		printf("11111110 (cmi)\n");

	else if ((ybpv & 0x01) && (ydata & 0x3b) == 0x11)

		printf("10101100 (loop)\n");

	else {

		printf("1");

		for (i = 0; i < 6; i++) {

			if (ydata & 0x20)

				printf("1");
			else

				printf("0");

			ydata <<= 1;

		}

		printf("1\n");

	}

}

print12(n)

unsigned int n;

{

	int i;

	for (i = 0; i < 12; i++) {

		if (n & 0x800)

			printf("1");

		else

			printf("0");

		n <<= 1;

	}

}

debug()

{

	printf("rdata = ");

	print12(rdata);

	printf("\n");

	printf("rbpv  = ");

	print12(rbpv);

	printf("\n");

	printf("k = %d\n", k);

}
