\chapter{How it works}

Eigenmath is written in the C programming language.
Its central data structure is
an array of one million 16-byte blocks of memory.

\begin{verbatim}
         _______ 
      0 |_______|  \
      1 |_______|   |
      2 |_______|   |
        |       |   |
        .       .   | 16,000,000 bytes
        .       .   |
        .       .   |
        |_______|   |
999,999 |_______|  /
\end{verbatim}

\medskip
\noindent
If necessary, Eigenmath will allocate additional memory in increments of one
million blocks.
The maximum amount of memory allocated is 160 million bytes,
or ten times what is shown above.

\newpage

\noindent
Each block is a union of structs.
The unsigned char $k$ identifies what type of information is stored in the
block.

\medskip
\begin{verbatim}
typedef struct U {
     union {
          struct {
               struct U *car;          // pointing down
               struct U *cdr;          // pointing right
          } cons;
          struct {
               struct U *binding;      // symbol's value binding
               struct U *arglist;      // formal argument list
          } sym;
          char *str;
          struct tensor *tensor;
          struct {
               unsigned int *a, *b;    // rational number a over b
          } q;
          double d;
     } u;
     unsigned char k, tag;
} U;
\end{verbatim}

\newpage

\noindent
Blocks are linked together to store mathematical expressions.
For example, the following shows how the expression
$A\times B+C$ is stored.

\begin{verbatim}
 _______      _______                                _______
|CONS   |--->|CONS   |----------------------------->|CONS   |
|       |    |       |                              |       |
|_______|    |_______|                              |_______|
    |            |                                      |
 ___v___      ___v___      _______      _______      ___v___
|ADD    |    |CONS   |--->|CONS   |--->|CONS   |    |SYMBOL |
|       |    |       |    |       |    |       |    |C      |
|_______|    |_______|    |_______|    |_______|    |_______|
                 |            |            |
              ___v___      ___v___      ___v___
             |TIMES  |    |SYMBOL |    |SYMBOL |
             |       |    |A      |    |B      |
             |_______|    |_______|    |_______|
\end{verbatim}

\medskip
\noindent
Only CONS blocks contain pointers to other blocks.
Every other kind of block is a terminal node.
Fundamentally, this approach is a subset of the S-expression data structure
invented by John McCarthy for the LISP programming language.

\newpage

\noindent
Confining pointers to CONS blocks differs from the more traditional linked
list data structure in a significant way.
In a linked list, blocks contain both data and pointers simultaneously.
For example, this is how one might store $A+B$ using a linked list.

\begin{verbatim}
 _______       _______       _______
|       |---->|       |---->|       |
|ADD    |     |SYMBOL |     |SYMBOL |
|       |     |A      |     |B      |
|_______|     |_______|     |_______|
\end{verbatim}

\medskip
\noindent
Now, suppose we want to store an additional expression, $A+C$.
Using a linked list, we have to make copies of the ADD and SYMBOL ``A'' blocks
because of the pointer data.
If we were to rewrite the pointer data we would destroy the original
expression.
However, with S-expressions all we have to do is allocate new CONS
blocks to create new expressions.
We never have to copy data.
We can store thousands of expressions with CONS
blocks all pointing to a common SYMBOL ``A'' block.

\medskip
\noindent
TBD

