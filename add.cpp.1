// Symbolic addition

// This is dead code, something I worked on Nov. 23, 2005.
// I thought this code would be faster because it uses qsort
// vs. add.cpp which uses an O(n^2) algorithm in some cases.
// However, it turns out that this code is a lot slower.
// The bondi metric before: 2 seconds. After: 44 seconds.
// Why is it so slow?
// It could be that too much time is spent doing garbage
// collection since this code creates two lists per term.
// Or it could be that the merge sort in the old add.cpp
// is perfect for the bondi metric calculation.

#include "stdafx.h"
#include "defs.h"

#define K(m) stack[h + n + 2 * m]
#define X(m) stack[h + n + 2 * m + 1]

void
eval_add(void)
{
	int h = tos;
	p1 = cdr(p1);
	while (iscons(p1)) {
		push(car(p1));
		eval();
		p2 = pop();
		push_terms(p2);
		p1 = cdr(p1);
	}
	yyadd(tos - h);
}

// n is the number of terms on the stack

void
yyadd(int n)
{
	int h, i, j;

	// partition the factors in each term

	h = tos - n;

	for (i = 0; i < n; i++) {
		p1 = stack[h + i];
		kfactors();
		p1 = stack[h + i];
		xfactors();
	}

	// sort all the terms

	qsort(stack + h + n, n, 2 * sizeof (U *), compare_terms);

	// fold terms

	for (i = 0; i < n - 1; i++) {
		if (iszero(K(i)))
			continue;
		for (j = i + 1; j < n; j++) {
			p1 = X(i);
			p2 = X(j);
			if (istensor(p1) && istensor(p2)) {
				push(p1);
				push(p2);
				tensor_plus_tensor();
				p3 = pop();
				if (p3 == nil)
					continue;
				X(i) = p3;
				K(j) = zero;
			} else if (equal(p1, p2) && fold_terms(K(i), K(j))) {
				K(i) = pop();
				K(j) = zero;
			}
		}
	}

	// reconstitution

	j = 0;

	for (i = 0; i < n; i++) {
		if (iszero(K(i)))
			continue;
		if (istensor(X(i))) {
			stack[h + j++] = X(i);
			continue;
		}
		p1 = K(i);
		p2 = X(i);
		reconstitute_term();
		stack[h + j++] = pop();
	}

	// epilog

	tos = h + j;

	switch (j) {
	case 0:
		push_integer(0);
		break;
	case 1:
		break;
	default:
		list(j);
		push(symbol(ADD));
		swap();
		cons();
		break;
	}
}

int
fold_terms(U *a, U *b)
{
	push(a);
	push(b);
	add_numbers();
	return 1;
}

void
reconstitute_term(void)
{
	int h;
	if (isplusone(p1))
		push(p2);
	else if (isplusone(p2))
		push(p1);
	else {
		h = tos;
		push_symbol(MULTIPLY);
		push_factors(p1);
		push_factors(p2);
		list(tos - h);
	}
}
		
int
kfac(U *p)
{
	if (p->k == NUM || p->k == DOUBLE)
		return 1;
//	else if (car(p1) == symbol(POWER) && cadr(p1)->k == NUM && caddr(p1)->k == NUM)
//		return 1;
	else
		return 0;
}

void
kfactors(void)
{
	int h = tos;
	if (car(p1) == symbol(MULTIPLY)) {
		p1 = cdr(p1);
		while (iscons(p1)) {
			if (kfac(car(p1)))
				push(car(p1));
			p1 = cdr(p1);
		}
	} else if (kfac(p1))
		push(p1);
	switch (tos - h) {
	case 0:
		push_integer(1);
		break;
	case 1:
		break;
	default:
		list(tos - h);
		push(symbol(MULTIPLY));
		swap();
		cons();
		break;
	}
}

void
xfactors(void)
{
	int h = tos;
	if (car(p1) == symbol(MULTIPLY)) {
		p1 = cdr(p1);
		while (iscons(p1)) {
			if (!kfac(car(p1)))
				push(car(p1));
			p1 = cdr(p1);
		}
	} else if (!kfac(p1))
		push(p1);
	switch (tos - h) {
	case 0:
		push_integer(1);
		break;
	case 1:
		break;
	default:
		list(tos - h);
		push(symbol(MULTIPLY));
		swap();
		cons();
		break;
	}
}

int
compare_terms(const void *a, const void *b)
{
	return cmp_expr(((U **) a)[1], ((U **) b)[1]);
}

void
push_terms(U *p)
{
	if (car(p) == symbol(ADD)) {
		p = cdr(p);
		while (iscons(p)) {
			push(car(p));
			p = cdr(p);
		}
	} else
		push(p);
}

void
push_factors(U *p)
{
	if (car(p) == symbol(MULTIPLY)) {
		p = cdr(p);
		while (iscons(p)) {
			push(car(p));
			p = cdr(p);
		}
	} else
		push(p);
}

void
add(void)
{
	int h;
	save();
	p2 = pop();
	p1 = pop();
	if (isnum(p1) && isnum(p2)) {
		push(p1);
		push(p2);
		add_numbers(); // mainly for numerical tensors
	} else {
		h = tos;
		push_terms(p1);
		push_terms(p2);
		yyadd(tos - h);
	}
	restore();
}

void
addk(int n)
{
	int h, i;
	save();
	h = tos - n;
	for (i = 0; i < n; i++) {
		p1 = stack[h + i];
		push_terms(p1);
	}
	yyadd(tos - h - n);
	p1 = pop();
	tos = h;
	push(p1);
	restore();
}

void
subtract(void)
{
	int h;
	save();
	p2 = pop();
	p1 = pop();
	if (isnum(p1) && isnum(p2)) {
		push(p1);
		push(p2);
		subtract_numbers();
	} else {
		h = tos;
		push_terms(p1);
		push(p2);
		negate();
		p2 = pop();
		push_terms(p2);
		yyadd(tos - h);
	}
	restore();
}
